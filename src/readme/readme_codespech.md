# 코드스피츠

## 상속과 확장

상속을 위한 경고 1
- 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다. super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라.

상속을 위한 경고 2
- 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

상속을 위한 경고 3
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

상속을 위한 경고 4
- 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.


#### 나쁜 확장

1. super는 나쁘다.
2. override는 나쁘다. 


#### 좋은 확장

1. super는 나쁘다.
- 부모의 모든 메소드는 final, private, abstract protected 
- 부모의 생성자는 인자를 받지 않음 

2. override는 나쁘다.
- 부모의 모든 메소드는 final, private, abstract protected 

위 내용을 지킬 수 없는 부모를 만들게 된다면 상속을 포기하고 합성을 사용해라


### 책임

- 부모가 대부분의 기능을 담당하고 자식은 조금만 위임하는 경우만 상속이 유용하다.
- 내가 책임을 안질꺼면 다 넘겨야 되고 (인터페이스와 비슷) 내가 책임을 질꺼면 조그만 기능을 넘겨야 한다.
- 그 이유는 상속되는 클래스는 어중간하게 넘길 때 문제가 된다. 다 넘기던가 조금만 넘겨야 한다. 모아니면 도 라는 법칙이라고 생각해도 된다. 

- 기능을 반반으로 구현 한다듯이 하면 어디가 책임이 되는지 분명하기 어렵다. 왜? 그떄 기준 그때 판단으로 나눴기 때문에 상황이 바뀌 문제가 바뀌면 이 모든게 망가지게 된다. -> 모아니면 도 원칙 책임 모델은 굉장히 극단적이다.
- 우리에게 남은건 책임을 엄청 작게 쪼개는 거 밖에 없다.

**객체 지향에서 중요한 것은 책임을 얼마나 작게 쪼개서 완전히 나눠 줄 수 있는가가 중요하다.**


### 의존성

#### 상속이 잘못 된 이유

- 자식이 부모를 아는 방향으로 의존성이 있다는게 잘못되어 있다. 
- 부모의 수정이 수많은 자식에게 영향을 끼칠 수 있다.
- 우리는 다운 캐스팅을 하면 안된다. 업캐스팅만 해야된다. 
- 리스코프 치환 원칙

### 템플릿 메소드 패턴과 전략 패턴

- 템플릿 메소드 패턴은 부모와 자식간의 의존성 방향을 역전시킨다.
- 부모가 자식을 아는 구조가 된다! 이렇게 떄문에 자식은 부모를 몰라도 되고 책임만 구현하면 된다.

우리는 자유 자재로 템플릿 메소드 패턴과 전략 패턴을 바꿀 수 있어야 한다.
이와 더불어 상속과 합성을 서로 변경할 수 있어야 한다.
마치 재귀함수를 For문으로 For문을 재귀함수로 바꾸듯이 말이다.

상속을 굳이 사용한 템플릿 메소드 패턴을 사용하면 의존성 관계가 심플해 진다. -> 의존성을 역전
전략 패턴은 중간에 전략 레이어를 끼어 넣는 걸로 단방향 의존성을 해결한다. 즉 템플릿 메소드 보다는 하나 더 의존성이 생기게 된다.

템플릿 : 런타임에 타입선택(세트), 추상메소드로 의존성 역전 -> 단점 : 조합 폭발이 일어난다. -> 해결 할 수 없다.
전략 : 런타임에 합성(조립), 추가 인터페이스로 의존성 분산 -> 단점 : 의존성 폭발 -> 해결 할 수 있다

훅이 1개인 템플릿 메소드가 가장 좋다.

### 생성사용패턴

생성 코드 - Client
사용 코드 - Service 

Client -> Service 객체를 주입(Injection)

설계할 때 중요한 것 중 하나는 생성 코드를 클라이언트로 밀어내는 것이다.

### 합성

상속와 합성을 언제 사용할까? 조합 폭발이 일어날 것 같으면 합성을 사용하자.
상속은 차이에 의한 프로그램이기 때문에 쉽다. 합성을 연습하자.


