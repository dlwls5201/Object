# 유연한 설계

## 01 개방-폐쇄 원칙

- 소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.

### 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라

- 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조라고 할 수 있다.

### 추상화가 핵심이다

- 개방-폐쇈 원칙의 핵심은 추상화의 의존하는 것이다.
- 단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설계를 만들 수 있는 것은 아니다. 개방-폐쇈 원칙에서 폐쇄를 가능하게 하는 것은 의존성의 방향이다. 수정에 대한 영향을 최소화 하기 위해서는 모든 요소가 추상화에 의존해야 한다.

## 02 생성 사용 분리

- 동일한 클래스 안에서 객체 생성과 사용이라는 두 가지 이질적인 목적을 가진 코드가 공존하는 것이 문제인 것이다.
- 유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임(생성과 사용)을 서로 다른 객체로 분리해야 한다.

### FACTORY 추가하기

- 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 FACTORY라고 부른다.

### 순수한 가공물에게 책임 할당하기

- 도메인 개념을 표현하는 객체와 순수하게 창조된 가공의 객체드이 모여 자신의 역활과 책임으 ㄹ다하고 조화롭게 협력하는 애플리케이션을 설계한느 것이 목표여야 한다.

## 03 의존성 주입

의존성 주입은 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록 만드는 방법을 포괄하는 명칭이다.
따라서 의존성 주입에서는 의존성을 해결하는 세 가지 방법을 가리키는 별도의 용어를 정의한다.

- 생성자 주입 : 객체를 생성한느 시점에 생성자를 통한 의존성 해결
- setter 주입 : 객체 생성 후 setter 메서드를 통한 의존성 해결
- 메서드 주입 : 메서드 실행 시 인자를 이용한 의존성 해결

### 숨겨진 의존성은 나쁘다

- Service Locator 패턴은 서비스를 사용하는 코드로부터 서비스가 누구인지, 어디에 있는지를 몰라도 되게 해준다.
- Service Locator 의 가장 큰 단점은 의존성을 숨긴다는 것이다.
- 의존성을 구현 내부로 감출 경우 의존성과 관련된 문제가 컴파일타임이 아닌 런타임에 가서야 발견된다는 사실을 알 수 있다. 숨겨진 의존성이 이해하기 어렵고 디버깅하기 어려운 이유는 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 떄문이다.

> 298p 단순히 private으로 선언한다고 캡슐화가 지켜지는 것은 아니다. 클래스의 퍼블릭 인터페이스만으로 사용 방법을 이해할 수 있는 코드가 캡슐화의 관점에서 훌륭한 코드다.


## 04 의존성 역전 원칙

### 추상화와 의존성 역전

- 상위 수준의 변경에 의해 하위 수준이 변경되는 것은 납득할 수 있지만 하위 수준의 변경으로 인해 상위 수준이 변경돼서는 곤란하다. 하위 수준의 이슈로 인해 사우이 수준에 위치하는 클래스들을 재사용하는 것이 어렵다면 이것 역시 문게가 된다.

1. 상위 수준의 모듈을 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화의 의존해야 한다.
2. 추상화는 구체적인 사항에 의존해서는 안 된다. 구체적인 사항은 추상화의 의존해야 한다.

### 의존성 역전 원칙과 패키지

- 역전은 의존성의 방향뿐만 아니라 인터페이스의 소유권에도 적용된다.
- 객체지향 프로그래밍 언어에서 어떤 구성 요소의 소유권을 결정하는 것은 모듈이다. (자바는 패키지를 이용해 모듈을 구현한다.)
- 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지에 포함시켜야 한다. 그리고 함께 재사용될 필요가 없는 클래스들은 별도의 독립적인 패키지에 모아햐 한다.

> p304 인터페이스의 소유권을 역전시킨 객체지향적인 모듈 구조는 대박이다.

## 05 유연성에 대한 조언

### 유연한 설계는 유연성이 필요할 때만 옳다

- 변경하기 쉽고 확장하기 쉬운 구조를 만들기 위해서는 단순함과 명확함의 미덕을 버리게 될 가능성이 높다.
- 유연한 설계라는 말의 이면에는 복잡한 설계라는 의미가 숨어 있다.
- 설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다.

### 협력과 책임이 중요하다

- 설계를 유연하게 만들기 위해서는 협력에 참여하는 객체가 다른 객체에게 어떤 메시지를 전송하는지가 중요하다.
- 설계를 유연하게 만들기 위해서는 먼저 역활, 책임, 협력에 초점을 맞춰야 한다.
- 핵심은 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절하다는 것이다.



