# 메시지와 인터페이스

훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다. 좀 더 정확하게 말해서 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다.
여기서 중요한 것은 책임이 객체가 수신할 수 있는 메시지의 기반이 된다는 것이다.

중요한것 : 객체들이 주고 받는 메시지

## 01 협력과 메시지

### 클라이언트-서버 모델

- 협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다.
- 메시지는 겍체 사이의 협력을 가능하게 하는 매개체다. 
- 객체가 다른 객체에게 접근할 수 있는 유일한 방법은 메시지를 전송하는 것뿐이다.

### 메시지와 메시지 전송

#### 메시지

객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다.

#### 메시지 전송

한 객체가 다른 객체에게 도움을 요청하는 것

### 메시지와 메서드

#### 메서드

메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저

- 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.
- 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 느슨하게 결할될 수 있게 한다.
- 메시지 전송자와 메시지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 얇고 가는 끈을 통해 연결된다. 
실행 시점에 메시지와 메서드를 바인딩하는 메커니즘은 두 객체 사이의 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 만든다. 

> 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다 -> 이게 두 객체 사이의 결합도를 낮추는 건가?

### 퍼블릭 인터페이스와 오퍼레이션

- 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부른다.
- 흔히 오퍼레이션이라고 부를 때는 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.
- 메시지를 수신했을 때 실제로 실행되는 코드는 메서드라고 부른다.
- 메서드는 오퍼레이션에 대한 구현이다.

### 시그니처

- 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 함쳐 시그니쳐라고 부른다.

|용어|내용|
|----|---|
|메시지|객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘. 일반적으로 객체의 오퍼레이션이 실행되도록 요청하는 것을 '메시지 전송'이라고 부른다.|
|오퍼레이션|객체가 다른 객체에게 제종하는 추상적인 서비스다. 메시지를 수신하는 객체의 인터페이스를 강조한다.|
|메서드|메시지에 응답하기 위해 실행되는 코드 블록을 메서드라고 부른다. 메서드는 오퍼레이션의 구현이다.|
|퍼블릭 인터페이스|객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음.|
|시그니처|오퍼레이션이나 메서드의 명세를 나타낸 것으로, 이름과 인자의 목록을 포함한다.|

## 02 인터페이스와 설계 품질

- 디미터 법칙 : 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것 (don't talk to strangers / only talk to your immediate neighbors / use only one dot) 
- 부끄럼 타는 코드 : 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드

> 186p 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수 있다?
디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한하는 거잖아. 근데 응집도가 낮아진다구?

### 묻지 말고 시켜라

- 절차적인 코드는 정보를 얻은 후에 결정한다. 객체지향 코드는 객체에게 그것을 하도록 시킨다.
- 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있다면 더 나은 방법은 없는지 고민해 보라
- 상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체하라


### 의도를 드러내는 인터페이스

켄트 벡의 메서드를 명명한느 두 가지 방법

1. 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것
> 188p에서 이건 추상화 작업이 들어간 메서드 아니라 private 한 함수에 대해서 좋다는 걸 의미하는 걸까?

2. 어떻게가 아니라 무엇을 하는지를 드러내는 것
> 요게 구현이 여러개인 메서드의 경우를 나타내는 거구나.

### 함께 모으기

 - 묻지 말고 시켜라
 - 인터페이스에 의도를 드러내자
 
 
## 03 원칙의 함정
 
 - 법칙에는 예외가 없지만 원칙에는 에외가 넘쳐난다.
 
### 디미터 법칙은 하나의 도트를 강제한느 규칙이 아니다.
 
 - 기차 충동처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.
 
### 결합도와 응집도의 충돌
 
> 201p Screening의 캡슐화를 향상시켰는데 응집도는 낮아지고 결합도는 높아졌네?

- 디미터 법칙의 위반 여부는 묻는 개상이 객체인지, 자료 구조인지에 달려있다고 설명한다. 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만 자료 구조라면 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없다.

## 04 명령-쿼리 분리 원칙

- 루틴 : 어떤 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
- 프로지서 : 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류
- 함수 : 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류

> 프로시저는 부수효과를 발생시킬 수 있지만 값을 반환할 수 없다고 한다. void 나 unit 과 같은 값을 반환하는 함수를 프로시저라고 생각하면 되는가?

명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나 부수효과를 발생기키지 않는 쿼리 중 하나여야 한다.

1. 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
2. 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

명령-쿼리 분리 원칙을 한 문장으로 표현하면 '질문이 답변을 수정해서는 안 된다.'는 것이다. 명령은 상태를 변경할 수 있지만 상태를 반환해서는 안된다. 쿼리는 객체의 상태를 반환할 수 있지만 상태를 변경해서는 안된다.

### 반복 일정의 명령과 쿼리 분리하기

- 반환 값을 돌려주는 메서드는 쿼리이다.
- 반환 값을 가지지 않는 메서드는 명령이다.

### 명령-쿼리 분리와 참조 투명성

- 참조 투명성 : 어떤 표현식 e가 있을 때 e의 값으로 e가 나타나는 모든 위치를 교체하더라도 결과가 달라지지 않는 특성
- 명령-쿼리 분리 원칙은 부수효과를 가지는 명령으로부터 부수효과를 가지지 않는 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다.

### 책임에 초점을 맞춰라

- 메시지를 먼저 선택하고 그 후에 메시지를 처라힐 객체를 선택하라
- 책임 주도 설계 방법에 따라 메시지가 객체를 결정하게 하라

> 부록 A 계약에 의한 걸계를 참고하라
6장을 줌심으로 쉬는 시간을 갖네,
1장 절차적 프로그래밍과 객체지향 프로그래밍의 차이점 그리고 객체지향 패러다임의 장점
4장과 5장 에서는 객체가 저장하는 데이터가 아니라 객체가 외부에 제공한느 책임을 기준으로 객체를 분해하는 방법이 가지는 장점
6장에서는 객체의 퍼블릭 인터페이스가 객체의 품질에 어떤 영향을 미치는지 알아봤다.

> 2장과 3장과 4장에서는 무엇을 했을까? 코드를 보며 다형성, 상속, 합성, 역활, 책임, 협력, 캡슐화, 결합도, 응집도에 대해 고민해 보았던것 같다.
